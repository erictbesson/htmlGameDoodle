<!DOCTYPE html>
<head>

	<title>Eric's JavaScript Combat Module for an RPG</title>
	<link rel="stylesheet" type="text/css" href="main.css">
	<meta charset="UTF-8"> 
	<script src="assets/jquery.js"></script>

	<script>

	var Battle = function(obj, bAlliesArray, bEnemiesArray) {
		if(bAlliesArray.length === undefined) {bAlliesArray = [bAlliesArray];}
		if(bEnemiesArray.length === undefined) {bEnemiesArray = [bEnemiesArray];}
		obj.bAlliesArray = bAlliesArray
		obj.bEnemiesArray = bEnemiesArray
		obj.competitorArray = obj.bAlliesArray.concat(obj.bEnemiesArray)
		obj.bTime = 0
		for(var i = 0; i < bAlliesArray.length; i++) {bAlliesArray[i].ally = true;}
		for(var i = 0; i < bEnemiesArray.length; i++) {bEnemiesArray[i].enemy = true;}
		$.extend(obj, Battle.methods)
		for(var i = 0; i < bAlliesArray.length; i++) {obj.bTurnAllyConstructer(i);}
		for(var i = 0; i < bEnemiesArray.length; i++) {obj.bTurnEnemyConstructer(i);}
		for(var i = 0; i < obj.competitorArray.length; i++) {
			obj.bDamagerConstructor(obj.competitorArray[i]);
			obj.competitorArray[i].bgConLog = obj.bgConLog
		}
		return obj
	}

	Battle.methods = {
		mainLoop : function(participantArray) {
			//var iTime = 0 //for DoT tick checks and for temporary early escape
			while(this.victoryCheck(participantArray) !== true) {
				for(var i = 0; i < participantArray.length; i++) {
					//participantArray[i].timestep(iTime);
					participantArray[i].timestep(this.bTime);
				}//temporary early break stuff
				if(this.bTime === 1000) {return 'early break due to too many reps'}
				//Refresh Allies?
				this.bTeamStatsUpdate(this.bAlliesArray);
				this.bTeamStatsUpdate(this.bEnemiesArray);
				//iTime++;
				this.bTime++;
			}
			console.log('(fight ended due to victory or defeat.)')
		},
		victoryCheck : function(competitorArray) {
			if(this.allies(competitorArray).length === 0) {
				console.log("Defeat!");
				return true;
			}
			if(this.enemies(competitorArray).length === 0) {
				console.log("Victory!", "Time: "+this.bTime);
				return true;
			}
			//console.log("the fight continues");
			return false;
		},
		allies : function(competitorArray) {
			allyList = [];
			for (var i = 0; i < competitorArray.length; i++) {
				if(competitorArray[i].ally) {
					if(competitorArray[i].hp > 0) {allyList.push(competitorArray[i]);}
				}
			}
			return allyList
		},
		enemies : function(competitorArray) {
			enemyList = [];
			for (var i = 0; i < competitorArray.length; i++) {
				if(competitorArray[i].ally !== true) {
					if(competitorArray[i].hp > 0) {enemyList.push(competitorArray[i]);}
				}
			}
			return enemyList
		},	
		binit : function() {
			this.bTeamStatsInit(this.bAlliesArray, "bAlliesStats");
			this.bTeamStatsInit(this.bEnemiesArray, "bEnemiesStats");
			this.bTeamStatsUpdate(this.bAlliesArray);
			this.bTeamStatsUpdate(this.bEnemiesArray);
			this.mainLoop(this.competitorArray);
		},
		bTeamStatsInit : function(competitorArray, docTeamId) {
			var bcuri = 0;
			var bresult = "";
			document.getElementById(docTeamId).innerHTML = ""
			while(bcuri < competitorArray.length) {
				var biresult = "<div class=col-"+12/competitorArray.length+" id="+competitorArray[bcuri].htmlname+bcuri.toString()+"></div>";
				bresult = bresult.concat(biresult);
				bcuri++;
			}
			document.getElementById(docTeamId).innerHTML = bresult;
		},
		bTeamStatsUpdate : function(competitorArray) {
			var bcuri = 0;
			while(bcuri < competitorArray.length) {
				document.getElementById(competitorArray[bcuri].htmlname+bcuri.toString()).innerHTML = "<p>"+competitorArray[bcuri].uname+"</p>"+"<p>HP: "+competitorArray[bcuri].hp+"</p>"+"<p> Readiness: "+competitorArray[bcuri].rdy+"</p>"+"</div>";
				bcuri++;
			}
		},
		bgConLog : function(bConLogText) {
			console.log("["+this.bTime.toString()+"] "+bConLogText)
			//Add code to add bConLogText to the html itself
		},
		bDamagerConstructor : function(bagent) {
			Object.defineProperty(bagent, 'dmg', {
				value : function(btarget, bagent, bvalue) {
					btarget.hp = btarget.hp - bvalue;
					this.bgConLog(bagent.uname+" hit "+btarget.uname+" for "+bvalue+" hp." );
					//other stuff for triggered events?
				}
			})
		},
		bTurnAllyConstructer : function(bArrayNum) {
			var bcEnemiesArray = this.bEnemiesArray;
			var bcCompetitor = this.competitorArray[bArrayNum];
			Object.defineProperty(this.competitorArray[bArrayNum], 'trn', {
				value: function() {
					bcCompetitor.dmg(bcEnemiesArray[Math.floor(Math.random(bcEnemiesArray.length))], bcCompetitor, bcCompetitor.atk);
					bcCompetitor.rdy = -1000;
				}
			})
			//return this.competitorArray[bArrayNum].trn;
		},
		bTurnEnemyConstructer : function(bArrayNum) {
			var bcAlliesArray = this.bEnemiesArray;
			var bcCompetitor = this.competitorArray[bArrayNum];			
			Object.defineProperty(this.competitorArray[bArrayNum], 'trn', {
				value: function() {
					bcCompetitor.dmg(bcAlliesArray[Math.floor(Math.random(bcAlliesArray.length))], bcCompetitor, bcCompetitor.atk);
					bcCompetitor.rdy = -1000;
				}
			})
			//return this.competitorArray[bArrayNum].trn;
		}
	}






	//Superclass for both ally and enemy participants


	var UnitCompetitor = function(obj, uname, mhp, atk, spd, def) {
		obj.uname = uname;
		obj.htmlname = uname.replace(" ", "_")
		obj.mhp = mhp;
		obj.hp = obj.mhp; //Make sure this does immutable assignment!
		obj.atk = atk;
		obj.spd = spd;
		obj.def = def;
		obj.rdy = -1000;
		obj.act = 0;
		obj.ugo = false;
		obj.trn = 'Place Holder';//Might be unnecessary.
		obj.dmg = 'Place Holder';
		obj.bgConLog = 'Place Holder';
		$.extend(obj, UnitCompetitor.methods);
		return obj
	}
	
	UnitCompetitor.methods = {
		//still editing timestep
		timestep : function(timeValue) {
			if(timeValue === undefined) {timeValue = 0}
			this.bTime = timeValue
			if(this.rdy <= 0) {this.rdy = this.rdy + this.spd;}
			if(this.rdy > 0) {this.rdy = this.rdy + 10 + Math.pow(this.spd, 1/3)}
			//console.log(this.uname+" is "+this.rdy.toString()+" ready at "+timeValue.toString())
			if(this.dots) {
				for (var i = 0; i < this.dots.length; i++) {
					this.dots[i].fx(timeValue);
				}
			if(this.rdy >= this.act) {this.trn;}//how can I get this function to reference the Battle Object???  What if battle assigns the property's attribute?
			}
		}
		// ,
		// turn : function() {
		// 	if(this.ugo = false) {
		// 		this.act = 1000;
		// 		this.ugo = true;
		// 	} else {
				

		// 		this.act = 0
		// 		this.ugo = false
		// 		this.rdy = -1000
		// 	}
		// },
		// uTestThis : function() {
		// 	return this
		// }

	}

	


	var hero = UnitCompetitor({}, 'Shepherd', 100, 10, 10, 10)
	var heroine = UnitCompetitor({}, 'Iura', 80, 10, 12, 8)

	var shero = UnitCompetitor({}, 'Shadow Shepherd', 100, 10, 10, 10)
	

	var DotConstructor = function(obj, zDotText, zDotRecipient, zDotFreq, zDotDamageC, zDotGiver) {
		if(zDotFreq === undefined) {zDotFreq = 1;}
		if(zDotGiver === undefined) {zDotGiver = zDotRecipient;}
		obj.zDotText = zDotText;
		obj.zDotRecipient = zDotRecipient;
		obj.zDotFreq = zDotFreq;
		obj.zDotDamageC = zDotDamageC;
		obj.zDotGiver = zDotGiver;
		$.extend(obj, DotConstructor.methods);
		return obj;
	}

	DotConstructor.methods = {
		fx : function(timeValue) {
			if(timeValue % this.zDotFreq === 0) {
				this.zDotRecipient.hp = this.zDotRecipient.hp - this.zDotDamageC*this.zDotGiver.atk;
				console.log(this.zDotText);
			}
		}
	}
	
	var sfade = DotConstructor({}, "the shadow fades!", shero, 100, 1, shero);

	

	

	shero.dots = [sfade]

	$.extend(shero, shero.dots)

	var sduo = [hero, shero]




var tBattle = Battle({}, hero, shero)

var fBattle = Battle({}, heroine, shero)

var twBattle = Battle({}, [hero, heroine], shero)
	// var battleInit = function() {

	// }




    </script>

</head>
<body>

	<div class='title_grid' id='bEnemiesStatsContainer'>
		<div class=row id='bEnemiesStats'>Enemy Stats should go here in columns!</div>
	</div>
	<br>
	<div class='title_grid' id='bAlliesStatsContainer'>
		<div class=row id='bAlliesStats'>Ally Stats should go here in columns!</div>
	</div>



	
</body>




<script>
//old script code
	//Main Loop
	var mainLoop = function(participantArray) {
		var iTime = 0 //for DoT tick checks and for temporary early escape
		while(victoryCheck(participantArray) !== true) {
			for(var i = 0; i < participantArray.length; i++) {
				participantArray[i].timestep(iTime);
			}
			//temporary early break stuff
			if(iTime === 100) {return 'early break due to too many reps'}
			iTime++
		}
		console.log('(fight ended due to victory or defeat.)')
	}

	var	victoryCheck = function(competitorArray) {
		//Eventually add code here to remove defeated heroes from competitorArray
		if(allies(competitorArray).length === 0) {
			console.log("Defeat!");
			return true;
		}
		if(enemies(competitorArray).length === 0) {
			console.log("Victory!");
			return true;
		}
		console.log("the fight continues");
		return false;
	}	
	


	//My goal here is to make a list of allies.  Ideally I want a list of allies that other things can access	
	//Wouldn't another method be to define the set during the initialization?
	
	//Note that the current allies and enemies functions require array
	var allies = function(competitorArray) {
		allyList = [];
		for (var i = 0; i < competitorArray.length; i++) {
			if(competitorArray[i].ally) {
				if(competitorArray[i].hp > 0) {allyList.push(competitorArray[i]);}
			}
		}
		return allyList
	}

	var enemies = function(competitorArray) {
		enemyList = [];
		for (var i = 0; i < competitorArray.length; i++) {
			if(competitorArray[i].ally !== true) {
				if(competitorArray[i].hp > 0) {enemyList.push(competitorArray[i]);}
			}
		}
		return enemyList
	}
</script>